/**
 * Auth Store - è®¤è¯ä¸»çŠ¶æ€ç®¡ç†
 * 
 * åŸºäºZustandçš„è®¤è¯çŠ¶æ€ç®¡ç†ï¼Œæä¾›ï¼š
 * - ç”¨æˆ·è®¤è¯çŠ¶æ€ç®¡ç†
 * - ç™»å½•/é€€å‡ºé€»è¾‘
 * - ä»¤ç‰Œç®¡ç†
 * - ç”¨æˆ·ä¿¡æ¯å­˜å‚¨
 */

import AsyncStorage from '@react-native-async-storage/async-storage';
import * as SecureStore from 'expo-secure-store';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';

// Types
import type {
    AuthMode,
    LoginRequest,
    LoginResponse,
    UserInfo
} from '../LoginMainPage/types';

// API services
import { authApi } from '../api/authApi';

// Constants
import { DEFAULT_STATE_VALUES, SECURE_KEYS } from '../LoginMainPage/constants';

// #region ç±»å‹å®šä¹‰

/**
 * è®¤è¯çŠ¶æ€æ¥å£
 */
export interface AuthState {
  // è®¤è¯çŠ¶æ€
  isAuthenticated: boolean;
  isInitialized: boolean;
  
  // ç”¨æˆ·ä¿¡æ¯
  userInfo: UserInfo | null;
  
  // è®¤è¯ä»¤ç‰Œ
  accessToken: string | null;
  refreshToken: string | null;
  tokenExpiry: Date | null;
  
  // ç™»å½•é…ç½®
  loginMode: AuthMode;
  rememberUser: boolean;
  
  // ä¼šè¯ä¿¡æ¯
  lastLoginTime: Date | null;
  deviceId: string | null;
  
  // ç”Ÿç‰©è¯†åˆ«
  biometricEnabled: boolean;
  biometricAvailable: boolean;
}

/**
 * è®¤è¯æ“ä½œæ¥å£
 */
export interface AuthActions {
  // åˆå§‹åŒ–
  initialize: () => Promise<void>;
  
  // ç™»å½•æ“ä½œ
  login: (credentials?: LoginRequest) => Promise<void>;
  passwordLogin: (phone: string, password: string, region: string) => Promise<void>;
  smsLogin: (phone: string, code: string, region: string) => Promise<void>;
  
  // é€€å‡ºç™»å½•
  logout: () => Promise<void>;
  clearAuthData: () => void;
  
  // ä»¤ç‰Œç®¡ç†
  refreshToken: () => Promise<void>;
  validateToken: () => Promise<boolean>;
  
  // çŠ¶æ€æ›´æ–°
  setUserInfo: (userInfo: UserInfo) => void;
  setLoginMode: (mode: AuthMode) => void;
  switchMode: (mode: AuthMode) => void;
  setRememberUser: (remember: boolean) => void;
  
  // ç”Ÿç‰©è¯†åˆ«
  setBiometricEnabled: (enabled: boolean) => void;
  checkBiometricAvailability: () => Promise<void>;
  
  // ä¼šè¯ç®¡ç†
  updateLastLoginTime: () => void;
  isTokenExpired: () => boolean;
  
  // è®¾å¤‡ç®¡ç†
  setDeviceId: (deviceId: string) => void;
}

/**
 * å®Œæ•´çš„è®¤è¯Storeç±»å‹
 */
export type AuthStore = AuthState & AuthActions;

// #endregion

// #region åˆå§‹çŠ¶æ€

/**
 * è®¤è¯çŠ¶æ€é»˜è®¤å€¼
 */
const initialAuthState: AuthState = {
  isAuthenticated: false,
  isInitialized: false,
  userInfo: null,
  accessToken: null,
  refreshToken: null,
  tokenExpiry: null,
  loginMode: DEFAULT_STATE_VALUES.loginMode,
  rememberUser: true,
  lastLoginTime: null,
  deviceId: null,
  biometricEnabled: false,
  biometricAvailable: false,
};

// #endregion

// #region å·¥å…·å‡½æ•°

/**
 * å®‰å…¨å­˜å‚¨æ“ä½œ
 */
const secureStorage = {
  async setItem(key: string, value: string): Promise<void> {
    try {
      await SecureStore.setItemAsync(key, value);
    } catch (error) {
      console.error('SecureStore setItem error:', error);
      // é™çº§åˆ°AsyncStorage
      await AsyncStorage.setItem(`secure_${key}`, value);
    }
  },
  
  async getItem(key: string): Promise<string | null> {
    try {
      return await SecureStore.getItemAsync(key);
    } catch (error) {
      console.error('SecureStore getItem error:', error);
      // é™çº§åˆ°AsyncStorage
      return await AsyncStorage.getItem(`secure_${key}`);
    }
  },
  
  async deleteItem(key: string): Promise<void> {
    try {
      await SecureStore.deleteItemAsync(key);
    } catch (error) {
      console.error('SecureStore deleteItem error:', error);
      // é™çº§åˆ°AsyncStorage
      await AsyncStorage.removeItem(`secure_${key}`);
    }
  },
};

/**
 * ä»¤ç‰Œå·¥å…·å‡½æ•°
 */
const tokenUtils = {
  /**
   * æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœŸ
   */
  isExpired(expiry: Date | null): boolean {
    if (!expiry) return true;
    return new Date() >= expiry;
  },
  
  /**
   * è§£æä»¤ç‰Œè¿‡æœŸæ—¶é—´
   */
  parseExpiry(token: string): Date | null {
    try {
      // ç®€å•çš„JWTè§£æï¼ˆå®é™…é¡¹ç›®ä¸­å¯èƒ½éœ€è¦æ›´å®Œå–„çš„JWTåº“ï¼‰
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.exp ? new Date(payload.exp * 1000) : null;
    } catch (error) {
      console.error('Token parsing error:', error);
      return null;
    }
  },
  
  /**
   * éªŒè¯ä»¤ç‰Œæ ¼å¼
   */
  isValid(token: string): boolean {
    if (!token) return false;
    const parts = token.split('.');
    return parts.length === 3;
  },
};

/**
 * è®¾å¤‡IDç”Ÿæˆå™¨
 */
const generateDeviceId = (): string => {
  return `device_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

// #endregion

// #region Storeåˆ›å»º

/**
 * åˆ›å»ºè®¤è¯Store
 */
export const useAuthStore = create<AuthStore>()(
  persist(
    (set, get) => ({
      // åˆå§‹çŠ¶æ€
      ...initialAuthState,
      
      // #region åˆå§‹åŒ–æ“ä½œ
      
      /**
       * åˆå§‹åŒ–è®¤è¯çŠ¶æ€
       */
      initialize: async () => {
        try {
          console.log('ğŸ” Initializing auth store...');
          
          // ä»å®‰å…¨å­˜å‚¨ä¸­æ¢å¤ä»¤ç‰Œ
          const accessToken = await secureStorage.getItem(SECURE_KEYS.ACCESS_TOKEN);
          const refreshToken = await secureStorage.getItem(SECURE_KEYS.REFRESH_TOKEN);
          const userCredentials = await secureStorage.getItem(SECURE_KEYS.USER_CREDENTIALS);
          
          let userInfo: UserInfo | null = null;
          
          // è§£æç”¨æˆ·å‡­æ®
          if (userCredentials) {
            try {
              userInfo = JSON.parse(userCredentials);
            } catch (error) {
              console.error('Parse user credentials error:', error);
            }
          }
          
          // æ£€æŸ¥ä»¤ç‰Œæœ‰æ•ˆæ€§
          const tokenExpiry = accessToken ? tokenUtils.parseExpiry(accessToken) : null;
          const isTokenValid = accessToken && tokenUtils.isValid(accessToken) && !tokenUtils.isExpired(tokenExpiry);
          
          // ç”Ÿæˆè®¾å¤‡IDï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
          const currentState = get();
          const deviceId = currentState.deviceId || generateDeviceId();
          
          // æ›´æ–°çŠ¶æ€
          set({
            accessToken: isTokenValid ? accessToken : null,
            refreshToken: isTokenValid ? refreshToken : null,
            tokenExpiry,
            userInfo: isTokenValid ? userInfo : null,
            isAuthenticated: isTokenValid,
            isInitialized: true,
            deviceId,
          });
          
          // å¦‚æœä»¤ç‰Œè¿‡æœŸä½†æœ‰åˆ·æ–°ä»¤ç‰Œï¼Œå°è¯•åˆ·æ–°
          if (!isTokenValid && refreshToken && tokenUtils.isValid(refreshToken)) {
            try {
              await get().refreshToken();
            } catch (error) {
              console.log('Auto refresh failed:', error);
              // åˆ·æ–°å¤±è´¥ï¼Œæ¸…é™¤æ‰€æœ‰è®¤è¯æ•°æ®
              await get().clearAuthData();
            }
          }
          
          console.log('âœ… Auth store initialized successfully');
        } catch (error) {
          console.error('âŒ Auth store initialization failed:', error);
          set({
            isInitialized: true,
            isAuthenticated: false,
          });
        }
      },
      
      // #endregion
      
      // #region ç™»å½•æ“ä½œ
      
      /**
       * é€šç”¨ç™»å½•æ–¹æ³•
       */
      login: async (credentials) => {
        try {
          console.log('ğŸ”‘ Starting login process...');
          
          if (!credentials) {
            throw new Error('Login credentials are required');
          }
          
          // æ·»åŠ è®¾å¤‡IDåˆ°è¯·æ±‚ä¸­
          const loginRequest: LoginRequest = {
            ...credentials,
            deviceId: get().deviceId || generateDeviceId(),
          };
          
          // è°ƒç”¨ç™»å½•API
          const response: LoginResponse = await authApi.login(loginRequest);
          
          if (!response.success || !response.data) {
            throw new Error(response.message || 'Login failed');
          }
          
          const { token, refreshToken: newRefreshToken, userInfo, expiresIn } = response.data;
          
          // è®¡ç®—ä»¤ç‰Œè¿‡æœŸæ—¶é—´
          const tokenExpiry = new Date(Date.now() + expiresIn * 1000);
          
          // ä¿å­˜åˆ°å®‰å…¨å­˜å‚¨
          await secureStorage.setItem(SECURE_KEYS.ACCESS_TOKEN, token);
          await secureStorage.setItem(SECURE_KEYS.REFRESH_TOKEN, newRefreshToken);
          await secureStorage.setItem(SECURE_KEYS.USER_CREDENTIALS, JSON.stringify(userInfo));
          
          // æ›´æ–°çŠ¶æ€
          set({
            isAuthenticated: true,
            accessToken: token,
            refreshToken: newRefreshToken,
            tokenExpiry,
            userInfo,
            lastLoginTime: new Date(),
          });
          
          console.log('âœ… Login successful');
        } catch (error) {
          console.error('âŒ Login failed:', error);
          throw error;
        }
      },
      
      /**
       * å¯†ç ç™»å½•
       */
      passwordLogin: async (phone, password, region) => {
        const credentials: LoginRequest = {
          phone,
          password,
          region,
        };
        
        await get().login(credentials);
      },
      
      /**
       * éªŒè¯ç ç™»å½•
       */
      smsLogin: async (phone, smsCode, region) => {
        const credentials: LoginRequest = {
          phone,
          smsCode,
          region,
        };
        
        await get().login(credentials);
      },
      
      // #endregion
      
      // #region é€€å‡ºç™»å½•
      
      /**
       * é€€å‡ºç™»å½•
       */
      logout: async () => {
        try {
          console.log('ğŸ‘‹ Starting logout process...');
          
          // è°ƒç”¨é€€å‡ºAPIï¼ˆå¯é€‰ï¼‰
          const { accessToken } = get();
          if (accessToken) {
            try {
              await authApi.logout();
            } catch (error) {
              console.warn('Logout API call failed:', error);
              // å³ä½¿APIè°ƒç”¨å¤±è´¥ï¼Œä¹Ÿè¦æ¸…é™¤æœ¬åœ°æ•°æ®
            }
          }
          
          // æ¸…é™¤è®¤è¯æ•°æ®
          await get().clearAuthData();
          
          console.log('âœ… Logout successful');
        } catch (error) {
          console.error('âŒ Logout failed:', error);
          // å³ä½¿å‡ºé”™ï¼Œä¹Ÿè¦æ¸…é™¤æœ¬åœ°æ•°æ®
          await get().clearAuthData();
        }
      },
      
      /**
       * æ¸…é™¤è®¤è¯æ•°æ®
       */
      clearAuthData: () => {
        // æ¸…é™¤å®‰å…¨å­˜å‚¨
        secureStorage.deleteItem(SECURE_KEYS.ACCESS_TOKEN);
        secureStorage.deleteItem(SECURE_KEYS.REFRESH_TOKEN);
        secureStorage.deleteItem(SECURE_KEYS.USER_CREDENTIALS);
        
        // é‡ç½®çŠ¶æ€
        set({
          isAuthenticated: false,
          accessToken: null,
          refreshToken: null,
          tokenExpiry: null,
          userInfo: null,
          lastLoginTime: null,
        });
      },
      
      // #endregion
      
      // #region ä»¤ç‰Œç®¡ç†
      
      /**
       * åˆ·æ–°ä»¤ç‰Œ
       */
      refreshToken: async () => {
        try {
          const { refreshToken: currentRefreshToken } = get();
          
          if (!currentRefreshToken || !tokenUtils.isValid(currentRefreshToken)) {
            throw new Error('Invalid refresh token');
          }
          
          console.log('ğŸ”„ Refreshing token...');
          
          // è°ƒç”¨åˆ·æ–°ä»¤ç‰ŒAPI
          const response = await authApi.refreshToken(currentRefreshToken);
          
          if (!response.success || !response.data) {
            throw new Error(response.message || 'Token refresh failed');
          }
          
          const { token, refreshToken: newRefreshToken, expiresIn } = response.data;
          const tokenExpiry = new Date(Date.now() + expiresIn * 1000);
          
          // ä¿å­˜åˆ°å®‰å…¨å­˜å‚¨
          await secureStorage.setItem(SECURE_KEYS.ACCESS_TOKEN, token);
          await secureStorage.setItem(SECURE_KEYS.REFRESH_TOKEN, newRefreshToken);
          
          // æ›´æ–°çŠ¶æ€
          set({
            accessToken: token,
            refreshToken: newRefreshToken,
            tokenExpiry,
            isAuthenticated: true,
          });
          
          console.log('âœ… Token refreshed successfully');
        } catch (error) {
          console.error('âŒ Token refresh failed:', error);
          // åˆ·æ–°å¤±è´¥ï¼Œæ¸…é™¤è®¤è¯çŠ¶æ€
          await get().clearAuthData();
          throw error;
        }
      },
      
      /**
       * éªŒè¯ä»¤ç‰Œ
       */
      validateToken: async () => {
        const { accessToken, tokenExpiry } = get();
        
        if (!accessToken || !tokenUtils.isValid(accessToken)) {
          return false;
        }
        
        if (tokenUtils.isExpired(tokenExpiry)) {
          // ä»¤ç‰Œè¿‡æœŸï¼Œå°è¯•åˆ·æ–°
          try {
            await get().refreshToken();
            return true;
          } catch (error) {
            return false;
          }
        }
        
        return true;
      },
      
      // #endregion
      
      // #region çŠ¶æ€æ›´æ–°
      
      /**
       * è®¾ç½®ç”¨æˆ·ä¿¡æ¯
       */
      setUserInfo: (userInfo) => {
        set({ userInfo });
        
        // åŒæ­¥åˆ°å®‰å…¨å­˜å‚¨
        secureStorage.setItem(SECURE_KEYS.USER_CREDENTIALS, JSON.stringify(userInfo));
      },
      
      /**
       * è®¾ç½®ç™»å½•æ¨¡å¼
       */
      setLoginMode: (mode) => {
        set({ loginMode: mode });
      },
      
      /**
       * åˆ‡æ¢ç™»å½•æ¨¡å¼
       */
      switchMode: (mode) => {
        set({ loginMode: mode });
      },
      
      /**
       * è®¾ç½®è®°ä½ç”¨æˆ·
       */
      setRememberUser: (remember) => {
        set({ rememberUser: remember });
      },
      
      // #endregion
      
      // #region ç”Ÿç‰©è¯†åˆ«
      
      /**
       * è®¾ç½®ç”Ÿç‰©è¯†åˆ«å¯ç”¨çŠ¶æ€
       */
      setBiometricEnabled: (enabled) => {
        set({ biometricEnabled: enabled });
      },
      
      /**
       * æ£€æŸ¥ç”Ÿç‰©è¯†åˆ«å¯ç”¨æ€§
       */
      checkBiometricAvailability: async () => {
        try {
          // è¿™é‡Œé›†æˆexpo-local-authentication
          // const { isAvailable } = await LocalAuthentication.hasHardwareAsync();
          // set({ biometricAvailable: isAvailable });
          
          // æš‚æ—¶è®¾ç½®ä¸ºfalseï¼Œåç»­é›†æˆç”Ÿç‰©è¯†åˆ«æ—¶å¯ç”¨
          set({ biometricAvailable: false });
        } catch (error) {
          console.error('Check biometric availability error:', error);
          set({ biometricAvailable: false });
        }
      },
      
      // #endregion
      
      // #region ä¼šè¯ç®¡ç†
      
      /**
       * æ›´æ–°æœ€åç™»å½•æ—¶é—´
       */
      updateLastLoginTime: () => {
        set({ lastLoginTime: new Date() });
      },
      
      /**
       * æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœŸ
       */
      isTokenExpired: () => {
        const { tokenExpiry } = get();
        return tokenUtils.isExpired(tokenExpiry);
      },
      
      /**
       * è®¾ç½®è®¾å¤‡ID
       */
      setDeviceId: (deviceId) => {
        set({ deviceId });
      },
      
      // #endregion
    }),
    {
      name: 'auth-store',
      storage: createJSONStorage(() => AsyncStorage),
      // åªæŒä¹…åŒ–éƒ¨åˆ†çŠ¶æ€
      partialize: (state) => ({
        loginMode: state.loginMode as AuthMode,
        rememberUser: state.rememberUser as boolean,
        deviceId: state.deviceId as string | null,
        biometricEnabled: state.biometricEnabled as boolean,
        lastLoginTime: state.lastLoginTime as Date | null,
      }),
      // ç‰ˆæœ¬æ§åˆ¶
      version: 1,
      migrate: (persistedState: any, version: number) => {
        console.log('ğŸ”„ Migrating auth store from version:', version);
        return persistedState as AuthStore;
      },
    }
  )
);

// #endregion

// #region å¯¼å‡º

// ä¾¿æ·çš„é€‰æ‹©å™¨å‡½æ•°
export const authSelectors = {
  isAuthenticated: (state: AuthStore) => state.isAuthenticated,
  userInfo: (state: AuthStore) => state.userInfo,
  loginMode: (state: AuthStore) => state.loginMode,
  isTokenExpired: (state: AuthStore) => state.isTokenExpired(),
};

// Note: ç±»å‹å·²åœ¨ä¸Šé¢å®šä¹‰å¹¶å¯¼å‡ºï¼Œè¿™é‡Œä¸éœ€è¦é‡å¤å¯¼å‡º

// #endregion
